# LearnGit
测试Git使用的练习册

## 简介

git的理论学习了很多。但是在实际使用过程中仍有很多未能解决的谜题。究其原因，git的项目管理能力太过于强大，又太过于灵活。导致面临的复杂情况比之svn有指数级别的增长。想要像学习svn一样学习git，通过一段时间的理论学习来理解其理论基础，然后就期望能做到一法通万法通的效果。这是不现实的，如果说svn的版本复杂度是树，枝枝杈杈就那么多，一目了然；那么git的版本复杂度兼职就是竹，看起来是一根一根的，实际上整片竹林都是同一条根生长出来的。要想透彻的理解git，除了需要对git版本管理的主体思想了然于胸之外。还需要进行大量的实践联系，并在实践中不断与理论理解相互印证。如此一段时间之后，才能做到真正入门。

## 第一天

### 创建仓库

github创建仓库的操作通常是在服务器端通过页面创建。具体操作只需要在个人的默认页面：`https://github.com`中，在Repositories面板中，选择【New repository】按钮即可。具体操作非常简单，此处不再赘述。创建仓库成功之后我们就有了一个远程仓库,仓库的地址是`https://github.com/dfiver/learngit.git`。远程仓库的主分支通常被称为`origin\master`。

### 根据远程仓库创建本地仓库

在希望创建创建本地仓库的目录下。使用命令：`git clone https://github.com/dfiver/learngit.git`即可创建本地仓库。本地仓库创建成功后，当前目录下会有一个`.git`的文件夹，这个文件夹里面存储的是仓库的信息。另外会有一个名为learngit的文件夹（与仓库的名字同名），这个是工作空间。本地仓库创建成功后，同步会创建一个与`origion/master`远程主分支对应的本地主分支`master`。

### 添加文件

通过`touch README.md`为项目添加一个文件。在README.md中，录入文档标题等说明性文字并保存。

> 此时通过'git checkout -b 1stday'命令创建并切换到新分支，由于master分支上存在未暂存的修改。那切换能否成功呢？如果成功了，此时1stday分支上是否有README.md这个文件呢？
>
> 答：由于1stday分支是从master分支创建出来的。因此，master上未暂存、未提交的修改都可以直接被带到1stday分支上。并且，可以在1stday分支上进行提交。如果这些修改在1stday分支上提交了。则master分支的log中是看不到这些修改的。之在1stday分支上能看到。这对于同时创建2个分支，用于开发两个不同的功能来说，是不能接受的。因此，如果在开发时本地同时创建了2个分支，用于开发不相干的两个功能。那么在进行分支切换之前，请务必确保当前分支已经提交。

### 提交本地修改

> 我们仍然回到`master`分支进行提交。如果之前切换到了1stday分支。只需要通过`git checkout master`命令，即可切换回master分支。之气在1stday分支上未暂存和未提交的修改，都可以直接代回到master分支。当然，如果已经提交了，那就带不回来了。好了，假设目前我们已经回到了master分支上。

使用命令`git commit -m "修改说明"`可以将本地修改提交到本地仓库。提交成功之后，本地仓库`origin/master`的版本会领先远程仓库1个提交。通常可以通过`push`命令来将本地仓库的提交推送到远程仓库中。

### 推送到远程仓库

如果本地分支的版本领先与远程分支，可以通过`git push`命令将本地分支的修改推送至远程分支。如何查看本地分支和远程分支的版本呢？可以通过'git log'命令。

## 第二天

### 创建分支

创建分支有两种方式：本地创建、远程创建。先看一下本地创建的方法。

#### 创建本地分支

通过命令`git checkout -b 分支名`可以在本地仓库上基于当前分支创建一个新分支。并且切换到该分支上。此处可以扩展思考的地方有两点。
1. 此前在`添加文件`这一小节中，曾经提到过：基于当前分支创建分支，并切换到新分支上之后。原有分支上为暂存和未提交的修改，均会被带到新分支上。
2. 由于我们之前的master分支是通过远程创建，然后clone到本地的，因此master分支存在其remote分支:`origin/master`，而新创建的分支(如果我们称其为2edday)由于是在本地创建，因此是没有远程分支与其对应的。此时，在2edday分支上，是不能进行push操作的。如果一定要操作，系统会提示先创建远程分支。并给出命令建议类似这样：`git push --set-upstream origin 2edday`。通过这样一个命令，实际上是给当前分支设置了远程分支，并进行了push操作。
> 设置远程分支的命令是:`git branch --set-upstream-to origion/分支名`

> `git push --set-upstream origin 2edday`还有一个简化的写法：`git push -u origin 2edday`

### 创建远程分支

创建远程分支有两种方式:
1. 一种是在本地创建本地分支，然后设定本地分支的远程分支。最后通过`git push`的方式在远程创建分支。如同在`创建本地分支`章节中描述的。
2. 另一种是直接通过远程仓库的页面创建分支，此时创建出的远程分支是没有本地分支的。需要通过类似`git checkout -b  2edday origin/2edday`这样的命令,将远程分支拉取到本地。
> 如果拉取到本地的分支名字可以允许与远程分支的名字一致，则拉取并创建本地分支的命令可以简化为`git checkout --track origion/2edday`。

### 设定本地分支跟踪远程分支
只有当本地的一个分支被设定为跟踪远程的一个分支时，才能进行`pull/push/fetch`的操作。在之前的`创建本地分支`章节中，可以看到，新创建的本地分支必须设定远程分支后才能执行`push`操作。在通过clone创建本地仓库时，默认设定本地仓库的master分支跟踪远程的`origion/master`分支，因此master分支是不需要手动设定远程分支，即可进行`pull/push/fetch`操作的。设定远程分支的命令是`git branch --set-upstream-to origin/2edday`。
> 通过git命令`git branch -vv`可以查看本地分支跟踪的远程分支是什么。

> 如果本地分支的版本与远程分支的版本不同。在通过`git branch --set-upstream-to`操作时，是不会报错的。只有在设定成功后。执行`pull`操作时，才会产生实质的`merge`操作，并可能产生冲突。由于`git pull`操作本身可以从任意分支获取信息并与当前分支`merge`。因此，设定本地分支跟踪一个不同版本的远程分支窃以为意义不大，而且极易产生冲突。建议不要这样操作。

#### 远程的origin分支和upstream分支
从远程仓库通过`git clone`的方式创建本地仓库后。远程仓库被设定为本地仓库的`origin`仓库，本地master分支被设定为跟踪远程的`origin/master`分支。通常情况下，我们设定本地分支跟踪的远程分支都是`origin`仓库下的同名分支。这样，本地仓库和远程仓库可以通过`pull/push/fetch`等操作进行同步。
但是远程仓库并不局限于`origin`这一个。本地仓库可以设定多个远程仓库，只要各个远程仓库的名字不同即可。同理，本地分支也可以设定为跟踪多个远程分支，甚至是不同仓库的多个分支，只要这些远程分支在版本关系上存在关联性即可。
> 设定`upstream`分支的操作在github或gitlab上最为常见。用于将原仓库中最新的修改同步到clone出来的仓库中。

## 第三天

### 克隆仓库

对于开发者来说，克隆仓库是一种非常常见的操作。常见的克操作分为两种：
1. 将远程仓库克隆为本地仓库
2. 在远程克隆一份仓库（fork)

#### 将远程仓库克隆为本地仓库
在`根据远程仓库创建本地仓库`这一章节中，已经演示了这一操作。在这一操作除了将远程仓库克隆到本地之外，还在本地创建master分支，并设定本地master分支跟踪远程的origin/master分支。

#### 在远程克隆一份仓库(fork)

这种操作通常需要通过git服务提供商的页面，例如github或者gitlab都能够提供该功能。这个功能有一个更加耳熟能详的名字`fork`。实际上，fork并不是一个git命令。只是git服务提供商用来描述在远程直接clone出分支这一行为而创建出的一个概念。
在通过github进行多人协作的项目管理时，通常核心仓库的权限对于非核心人员是不分配的。在github上，这种现象格外显著。解决的办法，是通过将项目主仓库拷贝一份，建立成个人的私有仓库。在私有仓库上进行修改和调整。如果感觉某个功能可以被纳入主版本，则通过pull-request的方式提交到主仓库。

#### pull-request工作流

无论github还是gitlab，都支持名为`pull-request`（或者简称PR）的git版本管理流程（也是开发流程或者多人协作流程）。该流程的主要步骤如下：
1. 开发人员基于主分支(origin/master)创建自己的远程分支。这一步骤通常被称为`fork`操作，无论github还是gitlab，都支持在界面上进行fork操作。
2. 开发人员将fork出来的分支clone到本地。
3. 开发人员在本地分支上完成开发工作。
4. 开发人员将本地分支上的修改提交到自己的远程分支。
5. 以上4、5两步可以重复执行，直到要开发的任务完成。可以向主分支提交。
6. 开发人员将主干的最新代码merge到本地分支。
7. 开发人员解决可能的冲突，并提交到自己远程分支。
8. 开发人员基于自己的远程分支创建一个`pull-request`请求。
9. 主分支的维护人员收到`pull-request`请求后进行审核，如果审核成功则合并该`pull-request`请求。
10. 然后开发人员可以选择删除掉自己的远程分支和本地分支。结束掉本次开发任务。


